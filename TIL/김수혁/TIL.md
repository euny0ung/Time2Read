# TIL
## 24.02.27
### 한 일
- 주제 선정 회의
- 주제 구체화
- 컨설턴트님과 코치님과의 컨설팅
- 데이터베이스 인덱스 학습

### 배운 것
- 인덱스란?
추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

- 인덱스의 장점
    - 데이터 검색 및 정렬 속도 향상
        - 조건 검색 Where절의 효율성
        Where절 사용 시 조건에 맞는 데이터를 찾기 위해 데이터를 탐색해야 하는데, 인덱스를 통해 데이터가 정렬되어 있으면 빠르게 찾아낼 수 있다
        - 정렬 Order by 정의 효율성
        Order by는 본래 부하가 많이 걸리는 작업이기 때문에 인덱스를 통해 이미 정렬되어 있으면 Order by를 피할 수 있다
        - MIN, MAX의 효율적인 처리 가능
        인덱스를 통해 정렬된 데이터에서 MIN, MAX를 효율적으로 추출할 수 있다
    - 쿼리 성능 향상
    - 조인 성능 향상

- 인덱스의 단점
    - 추가적인 공간 소모
        데이터베이스 내에서 인덱스 테이블을 생성하므로 추가적인 공간을 필요로 한다. (보통 DB의 10%정도의 추가 공간 필요)
    - 정렬된 상태를 계속 유지해야 함
        INSERT, UPDATE, DELETE 명령어가 수행된다면 정렬을 수행해야한다. 이러한 정렬을 DB에 부하를 발생시키기 때문에 인덱스는 데이터를 실제로 삭제하지 않고 다음과 같은 작업을 대신 수행한다
        - UPDATE : 기존의 데이터를 사용하지 않음 처리하고, 갱신된 데이터를 인덱스에 추가
        - DELETE : 삭제하는 데이터의 인덱스를 사용하지 않음 처리
        인덱스가 모든 쿼리에 도움을 주는 것은 아니다
        테이블의 개수가 적거나 조회하려는 데이터가 테이블의 대부분일때는 인덱스를 사용하지 않는 것이 더 속도가 빠르다

- 인덱스로 쓰이는 자료구조
    - 해시 테이블
        데이터 요소의 주소/인덱스 값이 해시 함수에서 생성되는 데이터 구조 유형이다.
인덱스 값이 데이터 값에 대한 키로 동작하기 때문에 매운 빠른 데이터 엑세스가 가능하다.
해시 테이블 기반 DB의 인덱스의 경우 (Key, Value)쌍을 저장하며 조회하는 동안 Key가 해시되고 결과 해시는 해당 값이 저장된 위치를 나타내게 된다
        - 특징
            - 성능 O(1)의 시작복잡도
            - 메모리 기반 데이터베이스에서 많이 사용
            - 정렬 X 
            - 데이터의 크기가 늘어나면 테이블의 크기도 증가
            - B-Tree의 경우, (a,b) 인덱스 테이블에서 a만 검색 가능, Hash Table의 경우 불가능
    - B-Tree
        B 트리는 트리 자료구조의 일종으로 이진트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조이다
        - 특징
            - 노드는 최대 M개의 자식 노드를 가질 수 있다
            - 노드에는 최대 M-1개의 KEY를 가질 수 있다
            - 각 노드에 저장된 키들은 항상 정렬된 상태를 유지한다
            - 연속적인 키 범위를 가지고 있기 때문에 범위 검색에 유리하다
            - 데이터 삽입과 삭제 시, 데이터 불균형이 발생하면 회전 및 재배치 연산을 통해 균형을 재조정한다

### 아직 잘 모르는 것
* [] 효율적인 인덱스를 활용하기 위한 데이터 처리 및 사용

---
## 24.02.28
### 한 일
- 주제 선정 회의
- 주제 구체화
- 스케줄러 학습

### 배운 것
- 스케줄러란?
어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드

- 스케줄러의 종류
    - 장기 스케줄러
    - 중기 스케줄러
    - 단기 스케줄러
        
- 스케줄링 알고리즘
    - FCFS
        - 먼저 준비된 프로세스를 먼저 처리
        - 간단하고 공정함 (우선순위, 실행시간 등의 다른 요소는 전혀 고려 X, 먼저 준비되면 먼저 실행)
        - 실행시간이 긴 프로세스 먼저 실행 시 대기시간이 길어짐
        - burst time이 긴 프로세스가 먼저 도착해 다른 프로세스의 실행 시간이 전부 늦처줘 효율을 떨어뜨리는 현상 발생
        - 비선점 스케줄링

    - SJF(Shortest Job First)
        - Starvation 발생 가능
        - burst time이 짧은 프로세스가 먼저 CPU를 할당
        - 비선점 스케줄링

    - SRT(Shortest Remaining Time First)
        - 남은 burst time이 더 짧은 프로세스에 CPU를 할당
        - Starvation 발생 가능
        - 선점 스케줄링    

    - 우선순위 스케줄링
        - 우선순위가 높은 프로세스에 CPU를 먼저 할당
        - 선점, 비선점 스케줄링 모두 가능
        - 기아 현상과 무기한 봉쇄가 발생할 수 있으며 에이징 기법을 통해 해결

    - 라운드 로빈
        - 프로세스에 동일한 할당 시간만큼 순서대로 계속 CPU를 할당
        - 선점형 스케줄링 방식
        - 응답시간이 빠르며, 모든 프로세스가 공정하게 CPU를 할당받을 수 있음을 보장
        
    - 다단계 큐
        - Background에서 돌아가는 프로세스와 Foreground의 프로세스에 다른 알고리즘을 적용하는 방식
        - 큐 사이에 서로 다른 CPU 할당시간 적용
        - Background에서는 FCFS, Foreground에서는 RR 알고리즘 적용
        - 선점 스케줄링 방식

    - 다단계 피드백 큐
        - 프로세스가 큐 사이를 이동 가능
        - 각 큐에 서로 다른 CPU 할당 시간을 적용함으로써, 프로세스가 해당 시간동안 작업을 다 처리하지 못했다면, 점점 긴 Time Quantum을 할당해주는 큐로 이동
        - 우선 순위는 Time Quantum이 짧은 큐가 높음
        - Starvation이 발생 가능하며 에이징을 통해 해결 가능

- 스케줄링 기법
    - 선점 스케줄링
        한 프로세스가 CPU를 할당받아서 실행하고 있을 때 다른 프로세스가 CPU를 사용하고 있는 프로세스를 중지시키고 CPU를 차지할 수 있는 스케줄링 기법
    - 비선점 스케줄링
        이미 사용되는 CPU를 빼앗지 못하고 사용이 끝날 떄까지 기다리는 스케줄링 기법

### 아직 잘 모르는 것
* [] 좋은 스케줄링 방식인지 확인하는 법

---
## 24.03.04
### 한 일
- 기획
- 뉴스 크롤링
- Typescript 학습

### 배운 것
- 변수 타입 지정
- Alias 사용법
- typescript에서의 오버로딩
- typescript에서의 polymorphism(다형성)
